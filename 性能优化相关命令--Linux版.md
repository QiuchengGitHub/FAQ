#性能优化相关命令
##vmstat
###命令使用
	vmstat m n
###命令说明
	m表示每隔m秒采集一次
	n表示只采集一次（n可以省略）
###命令执行效果
	[root@centos-master zcc]# vmstat 2
	procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
	 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
	 1  0      0 46363844    864 16782984    0    0     0     3    0    0  6  0 94  0  0
	 1  0      0 46364176    864 16782968    0    0     0     0 2196 1557  6  0 94  0  0
	 1  0      0 46366736    864 16782968    0    0     0     0 2037 1620  6  0 94  0  0
	 1  0      0 46367732    864 16782968    0    0     0    16 1869 1294  6  0 94  0  0
	 1  0      0 46368612    864 16782968    0    0     0    17 2206 1880  6  0 94  0  0
	 1  0      0 46369516    864 16782968    0    0     0    14 1852 1223  6  0 94  0  0
	 1  0      0 46369928    864 16782972    0    0     0     0 2274 1967  6  0 94  0  0
	 1  0      0 46370364    864 16782972    0    0     0     0 2554 2077  6  0 94  0  0
	 1  0      0 46370492    864 16782972    0    0     0     4 2235 1709  6  0 94  0  0
	 1  0      0 46370676    864 16782976    0    0     0    15 2134 1526  6  0 94  0  0
	 1  0      0 46370736    864 16782976    0    0     0    10 1730 1129  6  0 94  0  0
	 1  0      0 46370736    864 16782976    0    0     0     0 1896 1352  6  0 94  0  0
###采集数据解析
	-r 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。

	-b 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。
	
	-swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。
	
	-free 空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。
	
	-buff Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M
	
	-cache cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)
	
	-si  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。
	
	-so  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。
	
	-bi  块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒
	
	-bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。
	
	-in 每秒CPU的中断次数，包括时间中断
	
	-cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。
	
	-us 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。
	
	-sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。
	
	-id  空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。
	
	-wa wa列表示进程IO等待所占CPU时间百分比。wa值越高，说明IO等待越严重。如果wa值超过20%，说明IO等待严重。wa仅在Linux系统vmstat中显示。

	-st st列代表虚拟机占用CPU时间百分比。st仅在Linux系统vmstat中显示。

##top
###命令使用
	top
###命令说明
	-b 批处理

	-c 显示完整的治命令
	
	-I 忽略失效过程
	
	-s 保密模式
	
	-S 累积模式
	
	-i<时间> 设置间隔时间
	
	-u<用户名> 指定用户名
	
	-p<进程号> 指定进程
	
	-n<次数> 循环显示的次数
###命令执行效果
	top - 10:57:00 up 109 days, 17:22,  1 user,  load average: 0.84, 0.78, 0.79
	Tasks: 317 total,   1 running, 316 sleeping,   0 stopped,   0 zombie
	%Cpu(s):  6.3 us,  0.0 sy,  0.0 ni, 93.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
	KiB Mem : 65976812 total, 46324080 free,  2815024 used, 16837708 buff/cache
	KiB Swap:  4063228 total,  4063228 free,        0 used. 59284092 avail Mem 
	
	  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                   
	20950 root      20   0 6242232 442508  13760 S 100.3  0.7  60183:24 java                                                                                                                      
	   26 root      20   0       0      0      0 S   0.3  0.0 202:14.17 rcu_sched                                                                                                                 
	20609 root      20   0 10.522g 418812  14588 S   0.3  0.6  52:04.48 java                                                                                                                      
	31141 root      20   0  146416   2304   1444 R   0.3  0.0   0:01.66 top                                                                                                                       
	    1 root      20   0  191832   4908   2468 S   0.0  0.0 135:38.42 systemd                                                                                                                   
	    2 root      20   0       0      0      0 S   0.0  0.0   0:07.55 kthreadd                                                                                                                  
	    3 root      20   0       0      0      0 S   0.0  0.0   0:13.25 ksoftirqd/0                                                                                                               
	    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H                                                                                                              
	    7 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kworker/u33:0                                                                                                             
	    8 root      rt   0       0      0      0 S   0.0  0.0   0:06.26 migration/0                                                                                                               
	    9 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh                                                                                                                    
	   10 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/0                                                                                                                   
	   11 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/1                                                                                                                   
	   12 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/2                                                                                                                   
	   13 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/3                                                                                                                   
	   14 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/4                                                                                                                   
	   15 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/5                                                                                                                   
	   16 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/6                                                                                                                   
	   17 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/7                                                                                                                   
	   18 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/8                                                                                                                   
	   19 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/9                                                                                                                   
	   20 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/10                                                                                                                  
	   21 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/11                                                                                                                  
	   22 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/12                                                                                                                  
	   23 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/13                                                                                                                  
	   24 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/14
###采集数据解析
	一. 前五行是系统整体的统计信息
	1. 任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：
		其内容如下：
		|10:57:00	|当前时间	|
		|up 109 days, 17:22	|系统运行时间，格式为时:分	|
		|1 user	|当前登录用户数	|
		|load average: 0.84, 0.78, 0.79	|	系统负载，即任务队列的平均长度。 三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。	|
	2. Tasks — 任务（进程）信息
		其内容如下：
		|317 total	|进程总数	|
		|1 running	|正在运行的进程数	|
		|316 sleeping|睡眠的进程数	|
		|0 stopped	|停止的进程数	|
		|0 zombie	|僵尸进程数	|
	3. cpu状态信息（百分比）
		其内容如下：
		|6.3 us	|用户空间占用CPU百分比	|
		|0.0 sy	|内核空间占用CPU百分比	|
		|0.0 ni	|用户进程空间内改变过优先级的进程占用CPU百分比	|
		|93.7 id|空闲CPU百分比	|
		|0.0 wa	|IO等待占用CPU的百分比	|
		|0.0 hi	|硬中断（Hardware IRQ）占用CPU的百分比	|
		|0.0 si	|软中断（Software Interrupts）占用CPU的百分比	|
		|0.0 st	|虚拟机占用百分比	|
	4. 内存状态
		其内容如下：
		|65976812 total|物理内存总量	|
		|46324080 free|空闲内存总量	|
		|2815024 used|使用中的内存总量	|
		|16837708 buff/cache|用作内核缓存的内存量	|
	5. swap交换分区信息
		其内容如下：
		|65976812 total	|用户空间占用CPU百分比	|
		|46324080 free	|内核空间占用CPU百分比	|
		|2815024 used	|用户进程空间内改变过优先级的进程占用CPU百分比	|
		|16837708 buff/cache|空闲CPU百分比	|
	6. 各进程（任务）的状态监控信息
		其内容如下：
		|PID	|进程id	|	
		|PPID	|父进程id	|
		|USER	|进程所有者	|
		|PR		|进程优先级	|
		|NI		|nice值。负值表示高优先级，正值表示低优先级	|
		|VIRT	|进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES|
		|SWAP	|进程使用的虚拟内存中，被换出的大小，单位kb。|
		|RES	|进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA|
		|CODE	|可执行代码占用的物理内存大小，单位kb|
		|DATA	|可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb|
		|SHR	|共享内存大小，单位kb|
		|S		|进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程|
		|%CPU	|上次更新到现在的CPU时间占用百分比|
		|%MEM	|进程使用的物理内存百分比|
		|TIME+	|进程使用的CPU时间总计，单位1/100秒|
		|COMMAND|进程名称（命令名/命令行）|
###使用技巧
	1. 多U多核CPU监控
		在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况
	2. 高亮显示当前运行进程
		敲击键盘“b”（打开/关闭加亮效果）
	3. 通过”shift + >”或”shift + <”可以向右或左改变排序列

##iostat
###命令使用
	iostat -x 30
###命令说明
	30表示每隔30秒采集一次
###命令执行效果
	[root@centos-master zcc]# iostat -x 30
	Linux 3.10.0-229.el7.x86_64 (centos-master) 	03/06/2019 	_x86_64_	(16 CPU)
	
	avg-cpu:  %user   %nice %system %iowait  %steal   %idle
	           5.77    0.00    0.07    0.01    0.00   94.15
	
	Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
	fd0               0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00   61.00   61.00    0.00  61.00   0.00
	sda               0.00     0.37    0.00    5.23     0.13    41.09    15.75     0.01    1.50    3.19    1.49   0.31   0.16
	sdb               0.00     0.00    0.00    0.00     0.00     0.00     6.82     0.00    0.89    0.89    0.00   0.89   0.00
	sdc               0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00    0.03    0.03    0.00   0.03   0.00
	dm-0              0.00     0.00    0.00    5.60     0.13    41.09    14.70     0.01    1.55    3.47    1.55   0.29   0.16
	dm-1              0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00    2.47    2.47    0.00   0.51   0.00
	dm-2              0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00    0.69    0.69    0.00   0.69   0.00
	dm-3              0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00    0.02    0.02    0.00   0.02   0.00
###采集数据解析
	-Device 设备名称
	-rrqm/s	每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge）
	-wrqm/s 每秒这个设备相关的写入请求有多少被Merge了。
	-r/s
	-w/s
	-rkB/s
	-wkB/s
	-avgrq-sz 平均请求扇区的大小
	-avgqu-sz 是平均请求队列的长度。毫无疑问，队列长度越短越好
	-await 每一个IO请求的处理的平均时间（单位是毫秒）。这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。
	-r_await
	-w_await
	-svctm 表示平均每次设备I/O操作的服务时间（以毫秒为单位）。如果svctm的值与await很接近，表示几乎没有I/O等待，磁盘性能很好，如果await的值远高于svctm的值，则表示I/O队列等待太长，系统上运行的应用程序将变慢。
	-%util 在统计时间内所有处理IO时间，除以总共统计时间。例如，如果统计间隔1秒，该设备有0.8秒在处理IO，而0.2秒闲置，那么该设备的%util = 0.8/1 = 80%，所以该参数暗示了设备的繁忙程度。一般地，如果该参数是100%表示设备已经接近满负荷运行了（当然如果是多磁盘，即使%util是100%，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）。